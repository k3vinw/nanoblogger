#! /bin/sh --posix
############################################################
#  NanoBlogger 2.9 Copyright 2004 n1xt3r (Kevin R. Wood)   #
############################################################

# nanoblogger's version.
VERSION="CVS-2.9"

# nanoblogger's install directory.
BASE_DIR=`dirname $0`

# create a semi ISO 8601 formatted timestamp for archives
# used explicitly, please don't edit unless you know what you're doing.
NB_TimeStamp(){ date "+%Y-%m-%dT%H_%M_%S"; }

# prompt to use when asking something.
NB_PROMPT=": "

# set current path
CURR_PATH="$PWD"

# directory name to store archives
ARCHIVES="archives"

# directory name to store parts of weblog
PARTS_DIR="parts"

# directory name to store monthly archives
MONTHLY_DIR="$ARCHIVES/monthly"

# individual entry archives directory (automatically created)
PERMALINKS_DIR="$ARCHIVES/permalinks"

# the plugins directory name
PLUGINS_DIR="plugins"

# the templates directory name
TEMPLATE_DIR="templates"

# default verbosity, 0 = silent
VERBOSE="1"

# automatically set time zone using 'date +%z'
tzd_mm=`date +%z |cut -c4-5`; AUTO_TZD=`date +%z |sed 's/..$/\:'$tzd_mm'/'`

# letter to prepend to entry's html id tag
x_id="e"

nb_msg(){
[ "$VERBOSE" = "0" ] ||
	cat <<-EOF
		$@
	EOF
}

# function to die with a message
die(){
cat <<-EOF
	$@
EOF
exit 1
}

# die without it
[ -d "$BASE_DIR" ] ||
	die "`basename $0`: $BASE_DIR doesn't exist! bye."

# entry's new file for editing
NB_EditFile="/tmp/nb_entry$$.htm"

# cleanup for special temp files
tmp_files="$NB_EditFile"
[ -z "$tmp_files" ] || trap "rm -fr $tmp_files; exit" 0 1 2 3 15

# loads global and user configurations
load_config(){
# always load global configs
. "$BASE_DIR"/nb.conf
# check for user's .nb.conf in their home directory.
[ -f "$HOME/.nb.conf" ] && . "$HOME/.nb.conf"
# USR_BLOGDIR overrides BLOG_DIR
[ ! -z "$USR_BLOGDIR" ] && BLOG_DIR="$USR_BLOGDIR"
# default BLOG_CONF
BLOG_CONF="$BLOG_DIR/blog.conf"
# USR_BLOGCONF overrides BLOG_CONF
[ ! -z "$USR_BLOGCONF" ] && BLOG_CONF="$USR_BLOGCONF"
# load weblog config file
[ -f "$BLOG_CONF" ] && . "$BLOG_CONF"
# set data directory
[ ! -z "$BLOG_DIR" ] && NB_DATA_DIR="$BLOG_DIR/$ARCHIVES"
# BLOG_DATA_DIR overrides NB_DATA_DIR
[ ! -z "$BLOG_DATA_DIR" ] && NB_DATA_DIR="$BLOG_DATA_DIR"
# USR_DATADIR overrides NB_DATA_DIR, BLOG_DATA_DIR
[ ! -z "$USR_DATADIR" ] && NB_DATA_DIR="$USR_DATADIR"
# set template directory
[ ! -z "$BLOG_DIR" ] && NB_TEMPLATE_DIR="$BLOG_DIR/$TEMPLATE_DIR"
# BLOG_TEMPLATE_DIR overrides NB_TEMPLATE_DIR
[ ! -z "$BLOG_TEMPLATE_DIR" ] && NB_TEMPLATE_DIR="$BLOG_TEMPLATE_DIR"
# USR_TEMPLATE_DIR overrides NB_TEMPLATE_DIR, BLOG_TEMPLATE_DIR
[ ! -z "$USR_TEMPLATE_DIR" ] && NB_TEMPLATE_DIR="$USR_TEMPLATE_DIR"
# fallback to $USER
[ -z "$BLOG_AUTHOR" ] && BLOG_AUTHOR="$USER"
# fallback to vi
[ -z "$EDITOR" ] && EDITOR="vi"
# fallback to $BLOG_URL
[ -z "$BLOG_URL_ACTION" ] && BLOG_URL_ACTION="$BLOG_URL/"
# fallback to html
[ -z "$NB_FILETYPE" ] && NB_FILETYPE="html"
# fallback to xml
[ -z "$NB_SYND_FILETYPE" ] && NB_SYND_FILETYPE="xml"
# fallback to AUTO_TZD
[ -z "$BLOG_TZD" ] && BLOG_TZD="$AUTO_TZD"
}

# filter custom date format for a new entry
filter_dateformat(){
FILTER_VAR="$1"
[ -z "$FILTER_VAR" ] && FILTER_VAR="%B %d, %Y %l:%M %p"
# it might be cool to use the gnu date's description feature here
[ ! -z "$DATE_LOCALE" ] && LC_ALL="$DATE_LOCALE" date +"$FILTER_VAR"
[ -z "$DATE_LOCALE" ] && date +"$FILTER_VAR"
}

# change suffix of file
chg_suffix(){
filename="$1"
suffix="$2"
old_suffix=`echo $filename |cut -d"." -f2`
[ ! -z "$suffix" ] && NB_FILETYPE="$suffix"
echo "$filename" |sed -e '{$ s/\.'$old_suffix'$/\.'$NB_FILETYPE'/g; }'
}

# die without a default directory structure
check_blogdir(){
[ -z "$BLOG_DIR" ] && die "no weblog directory specified! bye."
[ ! -d "$BLOG_DIR" ] && die "weblog directory '$BLOG_DIR' doesn't exist! bye."
[ ! -d "$NB_DATA_DIR" ] && die "weblog's data directory '$NB_DATA_DIR' doesn't exist! bye."
[ ! -d "$NB_TEMPLATE_DIR" ] && die "weblog's templates directory '$NB_TEMPLATE_DIR' doesn't exist!. bye."
}

# create list of entries based on a month or interval
query_db(){
db_query="$1"
db_catquery="$2"
db_limit="$3"
db_offset="$4"
cd "$NB_DATA_DIR"
# get list of categories or accept a user specified list
if [ -z "$db_catquery" ] || [ "$db_catquery" = "nocat" ]; then
	db_catquery=
	db_categories=`for cat_db in cat_*.db; do echo "$cat_db"; done`
else
	db_categories="$db_catquery"
fi
if [ "$db_categories" = "cat_*.db" ]; then db_categories=; fi
	# list amount of entries based on db_limit
	filter_limit(){
		db_limit=`echo "$db_limit" |sed -e '/[A-Z,a-z,\-]/d'`
		db_offset=`echo "$db_offset" |sed -e '/[A-Z,a-z,\-]/d'`
		[ -z "$db_limit" ] && db_limit="$MAX_ENTRIES"
		[ -z "$db_offset" ] && db_offset="0"; db_offset=`expr 1 + $db_offset`
		[ ! -z "$db_limit" ] && sed -n "$db_offset,$db_limit"p; db_limit=; db_offset=
		}
        filter_query(){ grep "$db_query" |sort -ru; }
	# list all entries
        list_db(){ for files in *.htm; do echo "$files"; done; }
	# include categorized entries
	cat_db(){
		[ -z "$db_catquery" ] && list_db
		for cat_db in $db_categories; do
			[ ! -z "$cat_db" ] &&
				sed 1d "$cat_db"
		done
		}
if [ "$db_query" = "all" ]; then
	db_query=; DB_RESULTS=`cat_db |filter_query`
elif [ "$db_query" = "current" ]; then
	db_query=; DB_RESULTS=`cat_db |filter_query |filter_limit`
elif [ "$db_query" = "limit" ]; then
	db_query=; DB_RESULTS=`cat_db |filter_query |filter_limit`
else
	DB_RESULTS=`cat_db |filter_query`
fi
# try to clear bad data
if [ "$DB_RESULTS" = "$NB_DATA_DIR/*.htm" ]; then
	DB_RESULTS=
fi
db_query=; cd "$CURR_PATH"
}

# convert category number to existing category database
cat_id(){
cat_query=`echo "$cat_num" |grep '[0-9]' |sed -e '/,/ s// /g; /[A-Z,a-z\)\.-]/d'` 
query_db
if [ ! -z "$cat_query" ]; then
	for cat_id in $cat_query; do
		cat_valid=`echo "$db_categories" |grep cat_"$cat_id".db`
		echo "$cat_valid"
		[ -z "$cat_valid" ] &&
			echo "bad id('s)!"
	done
fi
}

# validate category's id number
check_catid(){
cat_list=`cat_id`
for cat_db in $cat_list; do
	[ ! -f "$NB_DATA_DIR/$cat_db" ] &&
		die "invalid category id('s): $cat_num"
done
[ ! -z "$cat_num" ] && [ -z "$cat_list" ] && die "must specify a valid category id!"
}

# filter content through a template
load_template(){
BLOG_FILE="$1"
# prefix text/html with an X in front of each line
BLOG_TEMPLATE=`sed -e '/^/ s//X/' <"$BLOG_FILE"`
# remove X's and source variables into a temp file
cat > "$BLOG_DIR"/nb_template.tmp <<EOF
	sed -e '/^X/ s///' <<-TMPL
	$BLOG_TEMPLATE
	TMPL
EOF
BLOG_HTML=`. "$BLOG_DIR"/nb_template.tmp`
rm -f "$BLOG_DIR"/nb_template.tmp
}

# load plugins from BASE_DIR/plugins and BLOG_DIR/plugins
load_plugins(){
PLUGINS_DIR="$1"
if [ "$ENABLE_PLUGINS" = "1" ]; then
	[ ! -d "$BASE_DIR/$PLUGINS_DIR" ] &&
		die "load_plugins: directory '$BASE_DIR/$PLUGINS_DIR' doesn't exist! bye."
	# loads plugins in alpha-numeric order (0-9, a-z)
	[ -d "$BLOG_DIR/$PLUGINS_DIR" ] &&
		for plugin in "$BLOG_DIR/$PLUGINS_DIR"/*.sh; do
			[ -f "$plugin" ] && . "$plugin"
		done
	for plugin in "$BASE_DIR/$PLUGINS_DIR"/*.sh; do
		[ -f "$plugin" ] && . "$plugin"
	done
fi
}

# read file's metadata
read_metadata(){
MTAG="$1"
META_FILE="$2"
NB_Metadata=`sed -n '/^'$MTAG'[\:]/p' "$META_FILE" |sed -e '/^'$MTAG'[\:][ ]/ s///'`
[ "$MTAG" = "BODY" ] &&
NB_Metadata=`sed -n '/^'$MTAG'[\:]/,/^[\-][\-][\-][\-][\-]/p' "$META_FILE" |sed -e '/^'$MTAG'[\:]/d; /^[\-][\-][\-][\-][\-]/d'`
}

# read an entry
read_entry(){
ENTRY_FILE="$1"
if [ -f "$ENTRY_FILE" ]; then
	month=`echo "$entry" |cut -c1-7`
	NB_EntryID="$x_id$entry"
	read_metadata TITLE "$ENTRY_FILE"; NB_EntryTitle="$NB_Metadata"
	read_metadata AUTHOR "$ENTRY_FILE"; NB_EntryAuthor="$NB_Metadata"
	read_metadata DATE "$ENTRY_FILE"; NB_EntryDate="$NB_Metadata"
	read_metadata DESC "$ENTRY_FILE"; NB_EntryDescription="$NB_Metadata"
	read_metadata BODY "$ENTRY_FILE"; NB_EntryBody="$NB_Metadata"
	if [ "$ENTRY_ARCHIVES" = "1" ]; then
		permalink_entry=`chg_suffix $entry`
		NB_EntryPermalink="$BLOG_URL/$PERMALINKS_DIR/$permalink_entry"
	else
		NB_EntryPermalink="$BLOG_URL/$MONTHLY_DIR/$month.$NB_FILETYPE#$NB_EntryID"
	fi
	load_plugins plugins/entry
fi
}

# write entry to file
write_entry(){
ENTRY_FILE="$1"
[ -z "$NB_EntryBody" ] &&
	die "NB_EntryBody contains no data! ...aborting."
cat > "$ENTRY_FILE" <<-EOF
	TITLE: $NB_EntryTitle
	AUTHOR: $NB_EntryAuthor
	DATE: $NB_EntryDate
	DESC: $NB_EntryDescription
	-----
	BODY:
	$NB_EntryBody
	-----
EOF
}

# create page from source and template files
make_page(){
MKPAGE_SRCFILE="$1"
MKPAGE_TMPLFILE="$2"
MKPAGE_OUTFILE="$3"
[ ! -z "$usr_title" ] && NB_EntryTitle=$usr_title
if [ ! -z "$usr_srcfile" ]; then
	MKPAGE_SRCFILE="$usr_srcfile"; MKPAGE_OUTFILE="$usr_outputfile"; MKPAGE_TMPLFILE="$usr_template"
	[ -z "$usr_template" ] && MKPAGE_TMPLFILE="$NB_TEMPLATE_DIR/$MAKEPAGE_TEMPLATE"
fi
[ ! -f "$MKPAGE_SRCFILE" ] && die "source file '$MKPAGE_SRCFILE' doesn't exist! bye."
NB_Entries=`cat "$MKPAGE_SRCFILE"`
[ -z "$MKPAGE_OUTFILE" ] && die "output file not specified."
[ ! -f "$MKPAGE_TMPLFILE" ] && die "template file '$MKPAGE_TMPLFILE' doesn't exist! bye."
# make sure the output directory is present before writing to it.
mkdir -p `dirname "$MKPAGE_OUTFILE"`
cat "$MKPAGE_TMPLFILE" > "$MKPAGE_OUTFILE".tmp
load_template "$MKPAGE_OUTFILE".tmp
echo "$BLOG_HTML" > "$MKPAGE_OUTFILE"
nb_msg "$MKPAGE_OUTFILE"
rm -f "$MKPAGE_OUTFILE".tmp
load_plugins plugins/postformat
}

# create individual page for an entry
build_permalink(){
permalink_entry=`chg_suffix $entry`
if [ "$template" = "$PERMALINKENTRY_TEMPLATE" ]; then
	if [ -f "$NB_DATA_DIR/$entry" ] && [ "$NB_DATA_DIR/$entry" -nt \
		"$BLOG_DIR/$PERMALINKS_DIR/$permalink_entry" ]; then
		echo "$BLOG_HTML" > "$BLOG_DIR/$PARTS_DIR/$entry"
		make_page "$BLOG_DIR/$PARTS_DIR/$entry" "$NB_TEMPLATE_DIR/$PERMALINK_TEMPLATE" \
		"$BLOG_DIR/$PERMALINKS_DIR/$permalink_entry"
	fi
fi
}

# generate archive content
make_archive(){
query_type="$1"
db_catquery="$2"
template="$3"
output_file="$4"
query_db "$query_type" "$db_catquery" "$db_limit"
ARCHIVE_LIST="$DB_RESULTS"
for entry in $ARCHIVE_LIST; do
	read_entry "$NB_DATA_DIR/$entry"
	load_template "$NB_TEMPLATE_DIR/$template"
	if [ ! -z "$BLOG_HTML" ]; then
		echo "$BLOG_HTML" >> "$BLOG_DIR"/archives.tmp
		build_permalink
		BLOG_HTML=
		PLACEHOLDER=
		NB_EntryCategories=
		NB_EntryCategoryTitle=
	fi
done
touch "$BLOG_DIR"/archives.tmp
cat "$BLOG_DIR"/archives.tmp > "$BLOG_DIR/$PARTS_DIR/$output_file"
rm -f "$BLOG_DIR"/archives.tmp
}

# create archive of current month
build_monthlyarchive(){
	if [ ! -z "$DB_RESULTS" ]; then
		make_archive "$month" nocat "$ENTRY_TEMPLATE" "$month".htm
		NB_ArchiveTitle="$month"
		load_plugins plugins/archive/monthly
		make_page "$BLOG_DIR/$PARTS_DIR/$month".htm "$NB_TEMPLATE_DIR/$MONTH_TEMPLATE" \
		"$BLOG_DIR/$MONTHLY_DIR/$month.$NB_FILETYPE"
	fi
}

# create all the monthly archives
cycle_months_for(){
	which_part="$1"
	query_db all
	MASTER_LIST="$DB_RESULTS"
	curr_year=`date +%Y`
	curr_month=`date +%m`
	# build archives seperated monthly and yearly
	ENTRY_YEARS=`echo "$MASTER_LIST" |cut -c1-4 |sort -ru`
	for yearn in $ENTRY_YEARS; do
		for monthn in 12 11 10 09 08 07 06 05 04 03 02 01; do
			ENTRY_LIST=`echo "$MASTER_LIST" |grep $yearn'[-]'$monthn'[-]' |sed -n 1p`
			for entry_month in $ENTRY_LIST; do
				month="$yearn-$monthn"
				query_db "$month"
				[ ! -z "$DB_RESULTS" ] && $which_part
			done
		done
	done
}

# helps update relative categories
find_categories(){
UPDATE_CATLIST="$1"
CAT_LIST=
	build_catlist(){
	if [ ! -z "$cat_var" ]; then
		CAT_LIST="$cat_db"
		[ "$CAT_LIST" != "$OLD_CATLIST" ] && CAT_LIST="$OLD_CATLIST $cat_db"
		OLD_CATLIST="$CAT_LIST"
	fi
	}
# find related categories for a given set of entries
for relative_entry in $UPDATE_CATLIST; do
	query_db "$db_query"
	for cat_db in $db_categories; do
		cat_var=`grep "$relative_entry" "$NB_DATA_DIR/$cat_db"`
		build_catlist
	done
done
[ -z "$CAT_LIST" ] && CAT_LIST="$db_catquery"
if [ "$blog_update" = "all" ]; then query_db; CAT_LIST="$db_categories"; fi
CAT_LIST=`for cat_id in $CAT_LIST; do echo "$cat_id"; done |sort -u`
}

# build category archives
build_catarchives(){
db_categories="$CAT_LIST"
if [ ! -z "$db_categories" ]; then
	for cat_arch in $db_categories; do
		if [ -f "$NB_DATA_DIR/$cat_arch" ]; then
			cat_archindex=`chg_suffix "$cat_arch"`
			cat_archpart=`chg_suffix "$cat_arch" htm`
			NB_ArchiveTitle=`sed -n 1p "$NB_DATA_DIR/$cat_arch"`
			make_archive all "$cat_arch" "$ENTRY_TEMPLATE" "$cat_archpart"
			make_page "$BLOG_DIR/$PARTS_DIR/$cat_archpart" "$NB_TEMPLATE_DIR/$CATEGORY_TEMPLATE" \
			"$BLOG_DIR/$ARCHIVES/$cat_archindex"
		fi
	done
fi
}

# create/update archives
build_archives(){
load_plugins plugins/archive
nb_msg "generating archives ..."
build_catarchives
if [ "$blog_update" = "all" ]; then
	cycle_months_for build_monthlyarchive
else
	# rebuild current month archive
	month=`date "+%Y-%m"`; this_month="$month"
	query_db "$month"; build_monthlyarchive

	# update relative monthly archives
	MOD_MONTHS=`echo "$UPDATE_LIST" |sed -e '/^[ ]/ s///g' |cut -c1-7 |sort -ru`
	for mod_month in $MOD_MONTHS; do
		if [ "$mod_month" != "$this_month" ]; then
			month="$mod_month"
			query_db "$month"; build_monthlyarchive
		fi
	done
	# update relative entry archives
	for mod_entry in $UPDATE_LIST; do
		if [ "$ENTRY_ARCHIVES" = "1" ] && [ -f "$NB_DATA_DIR/$mod_entry" ]; then
			entry="$mod_entry"
			read_entry "$NB_DATA_DIR/$entry"
			load_template "$NB_TEMPLATE_DIR/$PERMALINKENTRY_TEMPLATE"
			if [ ! -z "$BLOG_HTML" ]; then
				echo "$BLOG_HTML" > "$BLOG_DIR/$PARTS_DIR/$mod_entry"
				BLOG_HTML=
			fi
			permalink_file=`chg_suffix "$mod_entry"`
			make_page "$BLOG_DIR/$PARTS_DIR/$mod_entry" "$NB_TEMPLATE_DIR/$PERMALINK_TEMPLATE" \
			"$BLOG_DIR/$PERMALINKS_DIR/$permalink_file"
		fi
	done
fi
}

# generate the weblog files
build_blog(){
blog_update=`echo "$1" |sed -e '/\,/d; /[\)\.\-]/d'`
[ -z "$blog_update" ] && blog_update="current"
# query database and check for categories
db_catquery=`cat_id`; check_catid
find_categories "$UPDATE_LIST"
if [ "$blog_update" = "all" ]; then
	# remove all generated files for a clean build
	rm -fr "$BLOG_DIR/$PARTS_DIR"/*
	rm -fr "$BLOG_DIR/$MONTHLY_DIR"/*
	rm -fr "$BLOG_DIR/$PERMALINKS_DIR"/*
fi
load_plugins plugins
# build the archives
nb_msg "generating $NB_FILETYPE pages ..."
[ "$blog_update" != "main" ] && build_archives
if [ "$blog_update" != "main" ] && [ "$ENTRY_ARCHIVES" = "1" ]; then
	mkdir -p "$BLOG_DIR/$PERMALINKS_DIR"
	make_archive "$blog_update" nocat "$PERMALINKENTRY_TEMPLATE" permalinks.tmp
	rm -f "$BLOG_DIR/$PARTS_DIR"/permalinks.tmp
fi
# build main index
nb_msg "generating main index page ..."
make_archive current nocat "$ENTRY_TEMPLATE" news.htm
make_page "$BLOG_DIR/$PARTS_DIR"/news.htm "$NB_TEMPLATE_DIR/$MAIN_TEMPLATE" "$BLOG_DIR"/index.$NB_FILETYPE
}

# add a new entry
add_entry(){
New_EntryFile=`NB_TimeStamp`.htm
if [ ! -z "$cat_num" ]; then
	db_catquery=`cat_id`; check_catid
	for cat_db in $db_catquery ; do 
		echo "$New_EntryFile" >> "$NB_DATA_DIR/$cat_db"
	done
fi
nb_msg "processing weblog entry ..."
write_entry "$NB_DATA_DIR/$New_EntryFile"
[ "$build_newblog" = "1" ] && blog_update="all"
build_blog "$blog_update"
nb_msg "weblog entry added to '$BLOG_TITLE'."
}

# edit $BLOG_CONF
config_blog(){
if [ -f "$BLOG_CONF" ]; then
	$EDITOR "$BLOG_CONF"
	# check if file's been modified since opened
	[ ! -N "$BLOG_CONF" ] && die "no changes were made! bye."
	load_config; nb_msg "applying changes to '$BLOG_TITLE' ..."
	check_blogdir; build_blog; exit 0
else
	die "config file, '$BLOG_CONF' doesn't exist! bye."
fi
}

# edit entry or category by id number
edit_blog(){
if [ ! -z "$cat_num" ] && [ "$edit_num" = "cat" ]; then
	cat_var=`echo "$cat_num" |sed -e '/,/d'`
	[ -z "$cat_var" ] && die "must specify one category at a time when editing a title!"
	db_catquery=`cat_id`; check_catid
	query_db "$db_query" "$db_catquery"
	if [ ! -z "$usr_title" ]; then
		nb_msg "changing title to '$usr_title' for category id: $cat_num ..."
		echo "$usr_title" > "$NB_DATA_DIR/$db_catquery"
		[ ! -z "$DB_RESULTS" ] && echo "$DB_RESULTS" >> "$NB_DATA_DIR/$db_catquery"
		UPDATE_LIST="$DB_RESULTS"
		build_blog; exit 0
	else
		die "no changes were made! bye."
	fi
fi
NUMVAR=`echo "$edit_num" |grep '[0-9]' |sed -e '/\,/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "must specify a valid entry id."
db_catquery=`cat_id`; check_catid
query_db "$db_query" "$db_catquery"
Edit_EntryFile=`echo "$DB_RESULTS" |sed -n "$NUMVAR"p`
[ ! -f "$NB_DATA_DIR/$Edit_EntryFile" ] && die "invalid entry id: $NUMVAR"
$EDITOR "$NB_DATA_DIR/$Edit_EntryFile"
if [ -N "$NB_DATA_DIR/$Edit_EntryFile" ]; then
	nb_msg "processing weblog entry id: $NUMVAR ..."
	read_entry "$NB_DATA_DIR/$Edit_EntryFile"
	UPDATE_LIST="$Edit_EntryFile"
	build_blog
else
	die "no changes were made! bye."
fi
}

# import file as a new entry
import_file(){
[ ! -f "$entry_file" ] && die "import file '$entry_file', doesn't exist! bye."
[ ! -z "$usr_author" ] && NB_EntryAuthor=$usr_author
[ ! -z "$usr_title" ] && NB_EntryTitle=$usr_title
if [ -z "$NB_EntryAuthor$NB_EntryTitle" ]; then
	NB_EntryAuthor="Anonymous"; NB_EntryTitle="Untitled"
fi
NB_EntryBody=`cat "$entry_file"`
# create new timestamp
NB_EntryDate=`filter_dateformat "$DATE_FORMAT"`
add_entry; exit 0
}

# delete entry or category by id number
delete_blog(){
db_catquery=`cat_id`; check_catid
if [ ! -z "$cat_num" ]; then
	cat_list="$db_catquery"
	cat_msg=", from category id('s): $cat_num"
fi
if [ ! -z "$cat_num" ] && [ "$delete_num" = "cat" ]; then
	nb_msg "deleting category id('s): $cat_num ..."
	query_db "$db_query" "$cat_list"; UPDATE_LIST="$DB_RESULTS"
	for cat_db in $cat_list; do
		rm -f "$NB_DATA_DIR/$cat_db" "$BLOG_DIR/$ARCHIVES"/`chg_suffix "$cat_db"`
	done
	cat_num=; build_blog; exit 0
fi
NUMVAR=`echo "$delete_num" |grep '[0-9]' |sed -e '/\,/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "must specify a valid entry id!"
if [ ! -z "$cat_list" ]; then
	CATNUMVAR=`echo "$cat_num" |grep '[0-9]' |sed -e '/\,/ s// /g; /[A-Z,a-z\)\.\-]/d'`
	[ -z "$CATNUMVAR" ] &&
		die "must specify a single category when deleting entries from a category!"
fi
query_db "$db_query" "$cat_list"; ENTRY_LIST="$DB_RESULTS"
for entry_id in $NUMVAR; do
	Delete_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	[ ! -f "$NB_DATA_DIR/$Delete_EntryFile" ] && die "invalid entry id('s): $delete_num"
done
nb_msg "deleting weblog entry id('s): $delete_num$cat_msg ..."
for entry_id in $NUMVAR; do
	Delete_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	if [ -f "$NB_DATA_DIR/$Delete_EntryFile" ]; then
		DEL_LIST="$Delete_EntryFile"
		[ "$DEL_LIST" != "$OLD_DELLIST" ] && DEL_LIST="$OLD_DELLIST $Delete_EntryFile"
		OLD_DELLIST="$DEL_LIST"; UPDATE_LIST="$DEL_LIST"
		if [ ! -z "$cat_list" ]; then
			for cat_db in $cat_list; do
				cat_mod=`grep "$Delete_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ ! -z "$cat_mod" ]; then
					sed -e '/'$Delete_EntryFile'/d' "$NB_DATA_DIR/$cat_db" \
					> "$NB_DATA_DIR/$cat_db".tmp
					mv "$NB_DATA_DIR/$cat_db".tmp "$NB_DATA_DIR/$cat_db"
				fi
			done
		else
			for cat_db in $db_categories; do
				cat_mod=`grep "$Delete_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ ! -z "$cat_mod" ]; then
					sed -e '/'$Delete_EntryFile'/d' "$NB_DATA_DIR/$cat_db" \
					> "$NB_DATA_DIR/$cat_db".tmp
					mv "$NB_DATA_DIR/$cat_db".tmp "$NB_DATA_DIR/$cat_db"
				fi
			done
			rm -f "$NB_DATA_DIR/$Delete_EntryFile"
			Delete_PermalinkFile=`chg_suffix "$Delete_EntryFile"`
			if [ -f "$BLOG_DIR/$PERMALINKS_DIR/$Delete_PermalinkFile" ]; then
				rm -f "$BLOG_DIR/$PERMALINKS_DIR/$Delete_PermalinkFile"
			fi
		fi
	fi
done
build_blog
}

# list entries and categories
list_blog(){
query_db; db_query="$1"
db_catquery=`cat_id`; check_catid
if [ "$db_query" = "cat" ]; then
	[ -z "$db_categories" ] && die "no categories to list for '$BLOG_TITLE'! bye."
	echo "ID, Title"
	id=0
	cat_total=`echo "$db_categories" |grep "" -c`
	while [ "$id" != "$cat_total" ]; do
		id=`expr 1 + $id`
		if [ -f "$NB_DATA_DIR/cat_$id.db" ]; then
			echo " $id, `sed -n 1p "$NB_DATA_DIR"/cat_"$id".db`"
		else
			cat_total=`expr 1 + $cat_total`
		fi
	done; exit 0
fi
[ -z "$db_query" ] && db_query="current"
query_db "$db_query" "$db_catquery"
[ -z "$DB_RESULTS" ] && die "no entries to list for '$BLOG_TITLE'! bye."
echo "ID, Title [Category]"
id=0
for entry in $DB_RESULTS; do
	for cat_db in $db_categories; do
		cat_var=`grep "$entry" "$NB_DATA_DIR/$cat_db"`
		if [ ! -z "$cat_var" ]; then
			cat_title=`sed -n 1p "$NB_DATA_DIR/$cat_db"`
			[ "$cat_title" != "$oldcat_title" ] && cat_title="$oldcat_title $cat_title"
			oldcat_title="$cat_title,"
		fi
	done
	cat_title=`echo $cat_title |sed -e '{$ s/\,[ ]$//g; }'`
	[ ! -z "$cat_title" ] && NB_Category="[$cat_title]"
	read_metadata TITLE "$NB_DATA_DIR/$entry"; NB_EntryTitle="$NB_Metadata"
	id=`expr 1 + $id`
	echo " $id, $NB_EntryTitle $NB_Category"
	oldcat_title=; cat_title=; NB_Category=
done
}

# move entries into other categories
move_entry(){
NUMVAR=`echo "$move_num" |grep '[0-9]' |sed -e '/\,/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "must specify a valid entry id!"
query_db
for entry_id in $NUMVAR; do
	Move_EntryFile=`echo "$DB_RESULTS" |sed -n "$entry_id"p`
	[ ! -f "$NB_DATA_DIR/$Move_EntryFile" ] && die "invalid entry id('s): $move_num"
done
db_catquery=`cat_id`; check_catid; [ -z "$cat_num" ] && die "must specify category before entry!"
nb_msg "moving weblog entry id('s): $move_num, to category id('s): $cat_num ..."
UPDATE_LIST=`for entry_id in $NUMVAR; do echo "$DB_RESULTS" |sed -n "$entry_id"p; done`
query_db "$db_query" "$db_catquery"
for entry_id in $UPDATE_LIST; do
	Move_EntryFile="$entry_id"
	if [ -f "$NB_DATA_DIR/$Move_EntryFile" ]; then
		if [ ! -z "$db_catquery" ]; then
			for cat_db in $db_categories; do
				cat_mod=`grep "$Move_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ -z "$cat_mod" ]; then
					echo "$Move_EntryFile" >> "$NB_DATA_DIR/$cat_db"
				fi
			done
		fi
	fi
done
build_blog
}

preview_blog(){
[ -z "$BLOG_PREVIEW_CMD" ] && die "no BLOG_PREVIEW_CMD set for this weblog! bye."
nb_msg "running '$BLOG_PREVIEW_CMD' ..."
$BLOG_PREVIEW_CMD
}

preview_ask(){
echo "would you like to preview your weblog now? [y/N]"
read -p "$NB_PROMPT" choice
case $choice in
	[Yy])
		preview_blog;;
	[Nn]|"")
	;;
esac
}

publish_blog(){
[ -z "$BLOG_PUBLISH_CMD" ] && die "no BLOG_PUBLISH_CMD set for this weblog! bye."
nb_msg "running '$BLOG_PUBLISH_CMD' ..."
$BLOG_PUBLISH_CMD
}

publish_ask(){
echo "would you like to publish the weblog now? [y/N]"
read -p "$NB_PROMPT" choice
case $choice in
	[Yy])
		publish_blog;;
	[Nn]|"")
		;;
esac
}

# create a new entry or weblog directory
nb_main(){
[ -z "$BLOG_DIR" ] && die "no weblog directory specified! bye."
# automatically create new weblog directory.
if [ ! -d "$BLOG_DIR" ]; then
	build_newblog="1"
	mkdir -p "$BLOG_DIR"
	echo "creating weblog directory '$BLOG_DIR' ..."
	echo "copying default weblog files ..."
	cp -R "$BASE_DIR"/default/* "$BLOG_DIR"
	# but prompt for configuration.
	echo "would you like to configure the new weblog now? [Y/n]"
	read -p "$NB_PROMPT" choice
	case $choice in
	[Yy]|"")
		echo "configuring new weblog ..."
		$EDITOR "$BLOG_DIR"/blog.conf;;
	[Nn])
		echo "weblog not configured! use 'nb -b $BLOG_DIR --configure' to configure later."
	esac
fi
check_blogdir; load_config
# create a new category 
if [ ! -z "$cat_num" ]; then
	if [ "$cat_num" = "new" ]; then
		query_db; id=0
		cat_total=`echo "$db_categories" |grep "" -c`
		while [ "$id" != "$cat_total" ]; do
			id=`expr 1 + $id`
			if [ ! -f "$NB_DATA_DIR/cat_$id.db" ]; then
				echo "creating new category id: $id, for '$BLOG_TITLE' ..."
				if [ ! -z "$usr_title" ]; then
					cat_title=$usr_title; usr_title=
				else
					echo "please enter the new category's title [Untitled]"
					read -p "$NB_PROMPT" cat_title
					[ -z "$cat_title" ] && cat_title="Untitled"
				fi
				echo "$cat_title" > "$NB_DATA_DIR"/cat_"$id".db
				cat_num="$id"; db_catquery=`cat_id`; check_catid; cat_total="$id"
			else
				cat_total=`expr 1 + $cat_total`
			fi
		done
		echo "category database created for '$cat_title'."
		echo "would you like to add a new entry to this category now? [Y/n]"
		read -p "$NB_PROMPT" choice
		case $choice in
			[Yy]|"")
				# continue
				;;
			[Nn])
				build_blog "$blog_update"; exit 0
				;;
		esac
	else
		db_catquery=`cat_id`; check_catid
	fi
fi
# read user specified attributes for entry
[ ! -z "$usr_author" ] && NB_EntryAuthor=$usr_author
[ ! -z "$usr_title" ] && NB_EntryTitle=$usr_title
[ ! -z "$db_catquery" ] && cat_msg=" in category id('s): $cat_num"
echo "creating new entry for '$BLOG_TITLE'$cat_msg ..."
if [ -z "$NB_EntryAuthor" ]; then
	echo "enter author's name [$BLOG_AUTHOR]"
	read -p "$NB_PROMPT" NB_EntryAuthor
	[ -z "$NB_EntryAuthor" ] && NB_EntryAuthor="$BLOG_AUTHOR"
fi
if [ -z "$NB_EntryTitle" ]; then
	echo "enter a title"
	read -p "$NB_PROMPT" NB_EntryTitle
fi
echo "editing in '$EDITOR' ..."
$EDITOR "$NB_EditFile"
# load content of edited file into entry variable NB_EntryBody
if [ -f "$NB_EditFile" ]; then
	NB_EntryBody=`cat "$NB_EditFile"`
else
	die "can't continue, because your text-file wasn't saved! bye."
fi
# prompt for descritption
if [ -z "$NB_EntryDescription" ]; then
	echo "enter a short descriptive comment"
	read -p "$NB_PROMPT" NB_EntryDescription
fi
# generate date format for entry's content
NB_EntryDate=`filter_dateformat "$DATE_FORMAT"`
add_entry
[ ! -z "$BLOG_PREVIEW_CMD" ] && preview_ask
[ ! -z "$BLOG_PUBLISH_CMD" ] && publish_ask
}

show_help(){
cat <<-EOF
	NanoBlogger - Small console weblog engine.
	Version $VERSION, by Kevin Wood <un1xt3r@fastmail.fm>

	Usage:
	 `basename $0` [-b blogdir] [options]

	Options:
	 -a, --add				create new entry, category, or weblog
	 					(directory).
	 -b, --blogdir				specify weblog directory.
	 -c, --category	<new,number>		specify category (for '--add',
	 					'--delete', '--edit', '--list' and
	 					'--update').
	 --configure				configure weblog.
	 --datadir <directory>			specify weblog's data directory.
	 -d, --delete <cat,number>		delete an entry or category.
	 -e, --edit <cat,number>		edit an entry or category.
	 -f, --blogconf <file>			specify an alternate configuration
	 					file.
	 -h, --help				show this help message.
	 -i, --importfile <file>		specify file to import as new entry
	 -l, --list <all,cat,current>		list entries or categories
	 					(defaults to current entries).
	 --makepage <source> <output>		specify source and output file to
	 					create html page.
	 -m, --move <number>			move an entry to a specified category
	 					(for '--category').
	 -n, --author				author attribute of entry (for
	 					'--importfile' and '--add').
	 -p, --preview				run command to preview weblog.
	 -P, --publish				run command to publish weblog.
	 --template <file>			specify file to load as template (for
	 					'--makepage').
	 --templatedir <directory>		specify weblog's template directory.
	 -t, --title				title attribute of entry/category/page
	 					(for '--add', '--category',
	 					'--importfile', and '--makepage').
	 -u, --update <all,current,main>	force update of weblog (defaults to
	 					current).
	 -v, --verbose				toggle level of verbosity (on=1/off=0).
	 -V, --version				display version information.

	 -c,-d,-m accepts multiple numbers seperated by commas (e.g. 1,2,3).

	Examples:
	
	 specify the weblog directory to create or add new entry to
	 	nb -b ~/public_html/blog -a

	 creates new category and titles it "News"
	 	nb -b ~/public_html/blog -t "News" -c new -a

	 adds new entry to category 1
	 	nb -b ~/public_html/blog -c 1 -a

	 removes entry 2 from category 1
	 	nb -b ~/public_html/blog -c 1 -d 2

	 edits the title of category number 1
	 	nb -b ~/public_html/blog -c 1 -t Humor -e cat

	 creates new entry and uses the file 'message.txt' as it's content
	 	nb -b ~/public_html/blog -n myname -t 'my title' -i message.txt

	More info:
	 URL: http://home.columbus.rr.com/n1xt3r/nanoblogger/
EOF
}

argument=$@
[ $# -lt 1 ] && show_help
check_arg(){
if [ -z "$argument" ]; then
	echo "$bad_argument option requires an argument!"
	echo "Try '`basename $0` --help' for more information."
	exit 1
fi
}
sanity_check(){
invalid_opt=`echo "$argument" |grep '^[--]$*'`; [ ! -z "$invalid_opt" ] && argument=
}
while [ $# -gt 0 ]; do
	if [ $# -gt 1 ]; then
		argument=$2
	else
		bad_argument=$1
		argument=
	fi
	load_config
	case "$1" in
		-a|--add)		nb_main;;
		-b|--blogdir)		check_arg; USR_BLOGDIR="$2"; shift;;
		-c|--category)		check_arg; cat_num="$2"; shift;;
		--configure)		config_blog;;
		--datadir)		check_arg; USR_DATADIR="$2"; shift;;
		-d|--delete)		check_arg; delete_num="$2"; shift
					check_blogdir; delete_blog;;
		-e|--edit)		check_arg; edit_num="$2"; shift
					check_blogdir; edit_blog;;
		-f|--blogconf)		USR_BLOGCONF="$2"; shift;;
		-h|--help)		show_help; exit 0;;
		-i|--importfile)	check_arg; entry_file="$2"
					check_blogdir; import_file;;
		-l|--list)		db_query="$2"; shift
					check_blogdir; list_blog "$db_query";;
		-n|--author)		check_arg; usr_author="$2"; shift;;
		--makepage)		check_arg; usr_srcfile="$2"; usr_outputfile="$3"; shift 2
					check_blogdir; make_page;;
		-m|--move)		check_arg; move_num="$2"; shift
					check_blogdir; move_entry;;
		-p|--preview)		check_blogdir; preview_blog;;
		-P|--publish)		check_blogdir; publish_blog;;
		--template)		check_arg; usr_template="$2"; shift;;
		--templatedir)		check_arg; USR_TEMPLATE_DIR="$2"; shift;;
		-t|--title)		check_arg; usr_title="$2"; shift;;
		-u|--update)		blog_update="$2"; shift
					check_blogdir; build_blog "$blog_update";; 
		-v|--verbose)		check_arg; VERBOSE="$2"; shift;;
		-V|--version)		echo "NanoBlogger $VERSION"; exit 0;;
		--)			shift; break;;
		*)
					sanity_check
					echo "invalid option: $@"
					echo "Try '`basename $0` --help' for more information."
					exit 1
					;;
	esac
	shift
done

exit 0

#
# End of script
#
