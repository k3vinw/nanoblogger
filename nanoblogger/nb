#! /bin/bash
############################################################
#  NanoBlogger 3.3 Copyright 2005 n1xt3r (Kevin R. Wood)   #
############################################################
# Last modified: 2005-11-07T00:59:41-05:00

# nanoblogger's version.
VERSION="3.3-CVS"

# nanoblogger's base install directory.
NB_BASE_DIR=`dirname $0`

# nanoblogger's language definitions directory.
NB_LANG_DIR="${NB_BASE_DIR}/lang"

# nanoblogger's module directory.
NB_LIB_DIR="${NB_BASE_DIR}/lib"

# prompt to use when asking something.
NB_PROMPT=": "

# set current path
CURR_PATH="$PWD"

# the temp directory
TEMP_DIR=/tmp

# default verbosity, 0 = silent
VERBOSE=1

# automatically set time zone using GNU specific, 'date +%z'
tzd_mm=`date +%z |cut -c4-5`
AUTO_TZD=`date +%z |sed 's/..$/\:'$tzd_mm'/'`

# directory to store archives of weblog
ARCHIVES_DIR="archives"

# directory to store cached data of weblog
CACHE_DIR="cache"

# directory to store parts of weblog
PARTS_DIR="parts"

# letter to prepend to entry's html id tag
x_id=e

# cleanup for special temp files
SCRATCH_FILE="$TEMP_DIR/nb_scratch$$"
tmp_files="$TEMP_DIR/nb_entry$$.* $SCRATCH_FILE*"
[ ! -z "$tmp_files" ] && trap "rm -fr $tmp_files; exit" 0 1 2 3 15

# load the modules
. ${NB_LIB_DIR}/error.sh
. ${NB_LIB_DIR}/tools.sh
. ${NB_LIB_DIR}/config.sh
. ${NB_LIB_DIR}/query.sh

# insure a sane configuration or die
check_config(){
load_config
# die without the base directory
[ ! -d "$NB_BASE_DIR" ] &&
	die "`basename $0`: '$NB_BASE_DIR' - $checkconf_nobase."
[ -z "$BLOG_DIR" ] && die "$checkconf_noblog"
[ ! -z "$USR_BLOGCONF" ] &&
	[ ! -f "$USR_BLOGCONF" ] && die "'$USR_BLOGCONF' - $checkconf_nousrconf"
[ ! -d "$BLOG_DIR" ] && die "'$BLOG_DIR' - $checkconf_noblogdir"
[ ! -d "$NB_DATA_DIR" ] && die "'$NB_DATA_DIR' - $checkconf_nodata"
[ ! -d "$BLOG_DIR/$CACHE_DIR" ] && die "'$CACHE_DIR' - $checkconf_nocache"
[ ! -d "$NB_TEMPLATE_DIR" ] && die "'$NB_TEMPLATE_DIR' - $checkconf_notemplates"
}

# load specified plugins (defaults to all) from $PLUGINS_DIR
load_plugins(){
PLUGIN_DIR="$1"
PLUGIN_LIST=( ${@:1} )
add_plugin_script(){
	plugin_file="$1"
	if [ -f "$plugin_file" ] ; then
		plugin_scripts=( ${plugin_scripts[@]} "$plugin_file" )
	fi
}
# determine the plugin direcory
[ ! -z "$PLUGIN_DIR" ] && PLUGIN_DIR="/$1"
# stop short when plugins directory doesn't exist
plugin_path="$PLUGINS_DIR${PLUGIN_DIR}"
[ ! -d "$plugin_path" ] && return
# initialise the array of plugins
plugin_scripts=()
# were plugin names specified?
PLUGINLIST_VAR=`echo "${PLUGIN_LIST[*]}" |grep -c '.[ ].'`
if [ "$PLUGINLIST_VAR" != 0 ] ; then
	# yes, so we add them in order specified (removing any commas)
	for plugin in `echo ${PLUGIN_LIST[@]} |sed -e '/[\,]/ s// /g; /[ ][ ]/ s// /g'`; do
		nb_plugin="$plugin_path/${plugin}.sh"
		add_plugin_script "$nb_plugin"
 	done
else
	# no specified plugins, so get them all
	for nb_plugin in "$plugin_path"/*.sh ; do
		add_plugin_script "$nb_plugin"
	done
fi
# load the plugins in alpha-numeric order (0-9, A-z)
# ... except where specified elsewise
for nb_plugin in ${plugin_scripts[@]} ; do
	#nb_msg "loading `basename $nb_plugin` ..."
	. "$nb_plugin"
done
}

# filter content through a template
load_template(){
TEMPLATE_FILE="$1"
if [ -f "$TEMPLATE_FILE" ]; then
	# prefix lines with an X
	TEMPLATE=`sed -e '/^/ s//X: /' < "$TEMPLATE_FILE"`
	# remove X's and source variables into a temp file
	cat > "$SCRATCH_FILE" <<-EOF
		sed -e '/^X:[ ]/ s///' <<TMPL
			$TEMPLATE
		TMPL
	EOF
	TEMPLATE_DATA=`. "$SCRATCH_FILE"`
else
	die "'$TEMPLATE_FILE' - $loadtemplate_nofile"
fi
}

# read file's metadata
read_metadata(){
MTAG="$1"
META_FILE="$2"
MTAG_CLOSE=`echo "$MTAG" |sed -e '/[^ ].*[\,]/ s///'`
if [ "$MTAG" != "$MTAG_CLOSE" ] && [ ! -z "$MTAG_CLOSE" ]; then
	MTAG=`echo "$MTAG" |sed -e '/[\,].*[^ ]$/ s///'`
	METADATA=`sed -e '/^'$MTAG'[\:]/,/^'$MTAG_CLOSE'/!d; //d; /^'$MTAG'[\:]/d' "$META_FILE"`
else
	METADATA=`sed -e '/^'$MTAG'[\:]/!d; /^'$MTAG'[\:] */ s///' "$META_FILE"`
fi
}

# write metadata to file
write_metadata(){
MTAG="$1"
METADATA="$2"
META_FILE="$3"
MTAG_CLOSE=`echo "$MTAG" |sed -e '/[^ ].*[\,]/ s///'`
if [ ! -z "$MTAG" ] && [ ! -z "$METADATA" ]; then
	if [ "$MTAG" != "$MTAG_CLOSE" ] && [ ! -z "$MTAG_CLOSE" ]; then
		MTAG=`echo "$MTAG" |sed -e '/[\,].*[^ ]$/ s///'`
		if [ -f "$META_FILE" ]; then
			META_OTHER=`sed -e '/^'$MTAG'[\:]/,/^'$MTAG_CLOSE'/d; //d; /^'$MTAG'[\:]/d' "$META_FILE"`
		fi
		cat > "$META_FILE" <<-EOF
			$META_OTHER
			$MTAG:
			$METADATA
			$MTAG_CLOSE
		EOF
	else
		if [ -f "$META_FILE" ]; then
			META_OTHER=`sed -e '/^'$MTAG'[\:]/d' "$META_FILE"`
		fi
		# prepend modified or new single line tags
		cat > "$META_FILE" <<-EOF
			$MTAG: $METADATA
			$META_OTHER
		EOF
	fi
fi
}

# create/modify user metadata field
write_tag(){
WRITE_MTAG="$1"
WRITE_MTAGTEXT="$2"
WRITEMETATAG_FILE="$3"
[ ! -z "$USR_METATAG" ] && WRITE_MTAG="$USR_METATAG"
[ ! -z "$USR_TAGTEXT" ] && WRITE_MTAGTEXT="$USR_TAGTEXT"
if [ ! -z "$WRITE_MTAG" ]; then
	write_metadata "$WRITE_MTAG" "$WRITE_MTAGTEXT" \
		"$WRITEMETATAG_FILE"
fi
}

# load standard metadata from file into tangible shell variables
load_metadata(){
METADATA_TYPE="$1" # ALL or NOBODY :)
METADATA_FILE="$2"
if [ -f "$METADATA_FILE" ]; then
	read_metadata TITLE "$METADATA_FILE"; NB_MetaTitle="$METADATA"
	NB_EntryTitle="$NB_MetaTitle"
	read_metadata AUTHOR "$METADATA_FILE"; NB_MetaAuthor="$METADATA"
	NB_EntryAuthor="$NB_MetaAuthor"
	read_metadata DATE "$METADATA_FILE"; NB_MetaDate="$METADATA"
	NB_EntryDate="$NB_MetaDate"
	read_metadata DESC "$METADATA_FILE"; NB_MetaDescription="$METADATA"
	NB_EntryDescription="$NB_MetaDescription"
	read_metadata FORMAT "$METADATA_FILE"; NB_MetaFormat="$METADATA"
	NB_EntryFormat="$NB_MetaFormat"
	if [ "$METADATA_TYPE" = ALL ]; then
		read_metadata "BODY,$METADATA_CLOSETAG" "$METADATA_FILE"; NB_MetaBody="$METADATA"
		NB_EntryBody="$NB_MetaBody"
	fi
fi
}

# create file with metadata fields
make_file(){
WRITE_META_FILE="$1"
# give upgraders a break :)
[ ! -f "$NB_TEMPLATE_DI/$METADATAFILE_TEMPLATE" ] &&
	cp "$NB_BASE_DIR/default/templates/$METADATAFILE_TEMPLATE" "$NB_TEMPLATE_DIR"
load_template "$NB_TEMPLATE_DIR/$METADATAFILE_TEMPLATE"
echo "$TEMPLATE_DATA" > "$WRITE_META_FILE"
write_tag "$USR_METATAG" "$USR_TAGTEXT" "$WRITE_META_FILE"
}

# write entry's metadata to file
write_entry(){
WRITE_ENTRY_FILE="$1"
# give upgraders a break :)
[ ! -f "$NB_TEMPLATE_DIR/$METADATAENTRY_TEMPLATE" ] &&
	cp "$NB_BASE_DIR/default/templates/$METADATAENTRY_TEMPLATE" "$NB_TEMPLATE_DIR"
load_template "$NB_TEMPLATE_DIR/$METADATAENTRY_TEMPLATE"
echo "$TEMPLATE_DATA" > "$WRITE_ENTRY_FILE"
write_tag "$USR_METATAG" "$USR_TAGTEXT" "$WRITE_ENTRY_FILE"
}

# read an entry
read_entry(){
ENTRY_FILE="$1"
if [ -f "$ENTRY_FILE" ]; then
	NB_EntryID=`set_entryid $entry`
	load_metadata NOBODY "$ENTRY_FILE"
	load_plugins entry
	if [ "$ENTRY_FILE" -nt "$BLOG_DIR/$CACHE_DIR/$entry.entry_metadata" ]; then
		read_metadata "BODY,$METADATA_CLOSETAG" "$ENTRY_FILE"
		NB_EntryBody="$METADATA"
		load_plugins entry/mod
		[ -z "$NB_EntryFormat" ] && NB_EntryFormat="$ENTRY_FORMAT"
		load_plugins entry/format "$NB_EntryFormat"
		write_entry "$BLOG_DIR/$CACHE_DIR/$entry.entry_metadata"
		update_cache build entry_metadata "$entry"
	else
		load_metadata ALL "$BLOG_DIR/$CACHE_DIR/$entry.entry_metadata"
	fi
fi
}

# create weblog page from text (parts) files
make_page(){
MKPAGE_SRCFILE="$1"
MKPAGE_TEMPLATE="$2"
MKPAGE_OUTFILE="$3"
[ ! -z "$USR_TITLE" ] && MKPAGE_TITLE="$USR_TITLE"
if [ ! -z "$MKPAGE_TITLE" ]; then
	NB_MetaTitle="$MKPAGE_TITLE"
	# Set NB_EntryTitle for backwards compatibility
	NB_EntryTitle="$MKPAGE_TITLE"
fi
[ ! -z "$USR_SRCFILE" ] && MKPAGE_SRCFILE="$USR_SRCFILE"
[ ! -z "$USR_TEMPLATE" ] && MKPAGE_TEMPLATE="$USR_TEMPLATE"
[ ! -z "$USR_OUTFILE" ] && MKPAGE_OUTFILE="$USR_OUTFILE"
[ -z "$MKPAGE_TEMPLATE" ] &&
	MKPAGE_TEMPLATE="$NB_TEMPLATE_DIR/$MAKEPAGE_TEMPLATE"
[ ! -f "$MKPAGE_SRCFILE" ] && die "'$MKPAGE_SRCFILE' - $makepage_nosource"
[ -z "$MKPAGE_OUTFILE" ] && die "'$MKPAGE_OUTFILE' - $makepage_nooutput"
[ ! -f "$MKPAGE_TEMPLATE" ] && die "'$MKPAGE_TEMPLATE' - $makepage_notemplate"
# make sure the output directory is present before writing to it
mkdir -p `dirname "$MKPAGE_OUTFILE"`
set_baseurl "" "$MKPAGE_OUTFILE"
# load file as content
: ${MKPAGE_CONTENT:=$(< "$MKPAGE_SRCFILE")}
# let plugins modify the content
load_plugins page
: ${MKPAGE_FORMAT:=$PAGE_FORMAT}
load_plugins page/format "$MKPAGE_FORMAT"
# Set NB_Entries for backwards compatibility
NB_MetaBody="$MKPAGE_CONTENT"; NB_Entries="$MKPAGE_CONTENT"
load_template "$MKPAGE_TEMPLATE"
echo "$TEMPLATE_DATA" > "$MKPAGE_OUTFILE"
nb_msg "$MKPAGE_OUTFILE"
# load makepage plugins, but with reusable functionality
for mkpage_plugin in "$PLUGINS_DIR"/makepage/*.sh; do
	[ -f "$mkpage_plugin" ] && . "$mkpage_plugin"
done
MKPAGE_CONTENT=; MKPAGE_FORMAT=; MKPAGE_TITLE=; NB_MetaTitle=; NB_EntryTitle=
}

# create weblog page from metadata files
weblog_page(){
BLOGPAGE_SRCFILE="$1"
BLOGPAGE_TEMPLATE="$2"
BLOGPAGE_OUTFILE="$3"
[ ! -z "$USR_SRCFILE" ] && BLOGPAGE_SRCFILE="$USR_SRCFILE"
[ ! -z "$USR_TEMPLATE" ] && BLOGPAGE_TEMPLATE="$USR_TEMPLATE"
[ ! -z "$USR_OUTFILE" ] && BLOGPAGE_OUTFILE="$USR_OUTFILE"
if [ -f "$BLOGPAGE_SRCFILE" ]; then
	write_tag "$USR_METATAG" "$USR_TAGTEXT" "$BLOGPAGE_SRCFILE"
	load_metadata ALL "$BLOGPAGE_SRCFILE"
	[ ! -z "$USR_AUTHOR" ] && NB_MetaAuthor="$USR_AUTHOR"
	[ ! -z "$USR_DESC" ] && NB_MetaDescription="$USR_DESC"
	[ ! -z "$USR_TITLE" ] && NB_MetaTitle="$USR_TITLE"
	[ ! -z "$USR_TEXT" ] && NB_MetaBody="$USR_TEXT"
	MKPAGE_CONTENT="$NB_MetaBody"
	MKPAGE_FORMAT="$NB_MetaFormat"
	make_page "$BLOGPAGE_SRCFILE" "$BLOGPAGE_TEMPLATE" "$BLOGPAGE_OUTFILE"
fi
}

# create individual page for an entry
build_permalink(){
if [ "$ENTRY_ARCHIVES" = 1 ]; then
	if [ "$NB_DATA_DIR/$entry" -nt "$BLOG_DIR/$ARCHIVES_DIR/$permalink_file" ]; then
		mkdir -p `dirname "$BLOG_DIR/$PARTS_DIR/$permalink_file"`
		echo "$TEMPLATE_DATA" > "$BLOG_DIR/$PARTS_DIR/$permalink_file"
		make_page "$BLOG_DIR/$PARTS_DIR/$permalink_file" "$NB_TEMPLATE_DIR/$PERMALINK_TEMPLATE" \
		"$BLOG_DIR/$ARCHIVES_DIR/$permalink_file"
	fi
fi
}

# build entry archives
build_entryarchives(){
ENTRYARCHIVES_LIST="$1"
ENTRYARCHIVES_TEMPLATE="$2"
for entry in $ENTRYARCHIVES_LIST; do
	if [ -f "$NB_DATA_DIR/$entry" ]; then
		touch "$NB_DATA_DIR/$entry"
		[ -z "$PARTS_FILE" ] &&
			PARTS_FILE="$BLOG_DIR/$PARTS_DIR/$permalink_file"
		if [ "$ENTRYARCHIVES_TEMPLATE" = "$PERMALINKENTRY_TEMPLATE" ]; then
			set_baseurl "" "$BLOG_DIR/$ARCHIVES_DIR/$permalink_file"
			read_entry "$NB_DATA_DIR/$entry"
			set_entrylink "$entry"
			load_template "$NB_TEMPLATE_DIR/$ENTRYARCHIVES_TEMPLATE"
			[ ! -z "$TEMPLATE_DATA" ] &&
				echo "$TEMPLATE_DATA" >> "$PARTS_FILE"
			build_permalink
		else
			set_baseurl "$BASE_URL"
			read_entry "$NB_DATA_DIR/$entry"
			set_entrylink "$entry"
			load_template "$NB_TEMPLATE_DIR/$ENTRYARCHIVES_TEMPLATE"
			[ ! -z "$TEMPLATE_DATA" ] &&
				echo "$TEMPLATE_DATA" >> "$PARTS_FILE"
		fi
	fi
done
}

# generate archive content
make_archive(){
query_type="$1"
db_catquery="$2"
archive_template="$3"
PARTS_FILE="$4"
db_setlimit="$5"
db_limit="$6"
db_offset="$7"
query_db "$query_type" "$db_catquery" "$db_setlimit" "$db_limit" "$db_offset"
ARCHIVE_LIST="$DB_RESULTS"
mkdir -p `dirname "$PARTS_FILE"`
> "$PARTS_FILE"
build_entryarchives "$ARCHIVE_LIST" "$archive_template"
}

# divide larger archives into multiple pages
paginate(){
page_query="$1"
page_catquery="$2"
page_items="$3"
page_template="$4"
page_dir="$5"
page_file="$6"
page_fbasedir=`dirname "$page_file"`
if [ "$page_fbasedir" != . ]; then
	page_filedir="$page_fbasedir/"
	page_file=`basename "$page_file"`
fi
	update_pages(){
		build_pagelist(){
		if [ ! -z "$page_num" ]; then
			[ -z "$PAGE_LIST" ] && PAGE_LIST="page$page_num"
			[ "$PAGE_LIST" != "$OLD_PAGELIST" ] && PAGE_LIST="$OLD_PAGELIST page$page_num"
			OLD_PAGELIST="$PAGE_LIST"
		fi
		}
		query_db "$page_query" "$page_catquery" limit "$end" "$begin"
		for page_entry in $UPDATE_LIST; do
			if [ -z "$Edit_EntryFile" ]; then
				build_pagelist
			else
				page_match=`echo "$DB_RESULTS" |grep "$page_entry"`
				[ ! -z "$page_match" ] && build_pagelist
			fi
		done
		PAGE_LIST=`for page_n in $PAGE_LIST; do echo "$page_n"; done |sort -u`
	}
	page_bynumber(){
		set_baseurl "" "${page_dir}${page_filedir}$page_file"
		make_archive "$page_query" "$page_catquery" "$ENTRY_TEMPLATE" \
			"$BLOG_DIR/$PARTS_DIR/${page_filedir}$arch_file" limit "$end" "$begin"
		make_page "$BLOG_DIR/$PARTS_DIR/${page_filedir}$arch_file" \
			"$NB_TEMPLATE_DIR/$page_template" "${page_dir}${page_filedir}$arch_file"
	}
query_db "$page_query" "$page_catquery"
total_items=`echo "$DB_RESULTS" |grep -c "[\.]$NB_DATATYPE"`
if [ "$total_items" -gt "$page_items" ] && [ "$page_items" != 0 ]; then
	nb_msg "$paginate_action ${page_filedir}$page_file ..."
	get_pages(){ y=0; while [ "$y" -lt "$total_items" ]; do
		y=`expr $page_items + $y`; echo $y; done |grep -c "."; }
	total_pages=`get_pages`
	end=0; page_num=0
	while [ "$end" -lt "$total_items" ]; do
		begin=`expr "$end" + 1`; end=`expr "$page_items" + "$end"`
		page_num=`expr "$page_num" + 1`
		prev_num=`expr "$page_num" - 1`
		next_num=`expr "$page_num" + 1`
		arch_file="$page_file"
		arch_link="./$NB_INDEX"
		arch_name=`echo "$page_file" |cut -d"." -f 1`
		prev_page=`chg_suffix "$arch_name-page$prev_num".no`
		next_page=`chg_suffix "$arch_name-page$next_num".no`
		[ "$page_num" -gt 1 ] &&
			arch_file=`chg_suffix "$arch_name-page$page_num".no`
		> "$SCRATCH_FILE"
		echo '<br />' >> "$SCRATCH_FILE"
		[ "$prev_num" = 1 ] &&
			echo '<a href="'$arch_link'">'$NB_PrevPage'</a>' >> "$SCRATCH_FILE"
		[ "$prev_num" -gt 1 ] &&
			echo '<a href="'$prev_page'">'$NB_PrevPage'</a>' >> "$SCRATCH_FILE"
		i=1
		while [ $i -le $total_pages ]; do
			[ "$i" = 1 ] && page="$arch_link" ||
				page=`chg_suffix "$arch_name-page$i".no`
			if [ "$i" = "$page_num" ]; then
				echo '['$i']' >> "$SCRATCH_FILE"
			else
				echo '<a href="'$page'">['$i']</a>' >> "$SCRATCH_FILE"
			fi
			i=`expr $i + 1`
		done
		! [ "$next_num" -gt "$total_pages" ] &&
				echo '<a href="'$next_page'">'$NB_NextPage'</a>' >> "$SCRATCH_FILE"
		NB_PageLinks=$(< "$SCRATCH_FILE")
		if [ ! -z "$UPDATE_LIST" ] && [ ! -z "$USR_QUERY" ]; then
			update_pages
			for page_mod in $PAGE_LIST; do
				[ "page$page_num" = "$page_mod" ] && page_bynumber
			done
		else
		page_bynumber
		fi
		NB_PageLinks=
	done
else
	set_baseurl "" "${page_dir}${page_filedir}$page_file"
	make_archive "$page_query" "$db_catquery" "$ENTRY_TEMPLATE" "$BLOG_DIR/$PARTS_DIR/${page_filedir}$page_file"
	make_page "$BLOG_DIR/$PARTS_DIR/${page_filedir}$page_file" "$NB_TEMPLATE_DIR/$page_template" \
		"${page_dir}${page_filedir}$page_file"
fi
page_filedir=
}

# create archive of current month
build_montharchive(){
query_db "$month"
if [ ! -z "$DB_RESULTS" ]; then
	set_monthlink "$month"
	set_baseurl "" "$BLOG_DIR/$ARCHIVES_DIR/$month_file"
	make_archive "$month" nocat "$ENTRY_TEMPLATE" "$BLOG_DIR/$PARTS_DIR/$month_file"
	NB_ArchiveTitle="$month"
	load_plugins archive/month
	make_page "$BLOG_DIR/$PARTS_DIR/$month_file" "$NB_TEMPLATE_DIR/$MONTH_TEMPLATE" \
	"$BLOG_DIR/$ARCHIVES_DIR/$month_file"
fi
}

# loops through archives, and executes instructions by years or months
loop_archive(){
looparch_list="$1"
looparch_type="$2"
looparch_exec="$3"
# set instructions to execute based on $looparch_type
if [ "$looparch_type" = years ]; then
	looparchexec_years="$looparch_exec"
elif [ "$looparch_type" = months ]; then
	looparchexec_months="$looparch_exec"
fi
ARCHIVE_MASTER="$looparch_list"
ARCHIVE_YEARS=`echo "$ARCHIVE_MASTER" |cut -c1-4 |sort $SORT_ARGS`
for yearn in $ARCHIVE_YEARS; do
	# execute instructions for each year
	[ ! -z "$DB_RESULTS" ] && [ ! -z "$looparchexec_years" ] &&
		$looparchexec_years
	for monthn in 12 11 10 09 08 07 06 05 04 03 02 01; do
		ARCHIVE_MONTHS=`echo "$ARCHIVE_MASTER" |grep $yearn'[-]'$monthn'[-]' |sed 1q`
		for entry_month in $ARCHIVE_MONTHS; do
			month="$yearn-$monthn"
			query_db "$month"
			# execute instructions for each month
			[ ! -z "$DB_RESULTS" ] && [ ! -z "$looparchexec_months" ] &&
				$looparchexec_months
		done
	done
done
}

# build category archives
build_catarchives(){
db_categories="$CAT_LIST"
if [ ! -z "$db_categories" ]; then
	for cat_arch in $db_categories; do
		if [ -f "$NB_DATA_DIR/$cat_arch" ]; then
			NB_ArchiveTitle=`sed 1q "$NB_DATA_DIR/$cat_arch"`
			set_catlink "$cat_arch"
			paginate all "$cat_arch" "$MAX_PAGE_ENTRIES" "$CATEGORY_TEMPLATE" \
				"$BLOG_DIR/$ARCHIVES_DIR/" "$category_file"
		fi
	done
fi
}

# update the cache
update_cache(){
cache_update="$1"
cache_def="$2"
CACHEUPDATE_LIST="$3"
> "$SCRATCH_FILE-$cache_def".cache_list
if [ "$cache_update" = build ]; then
	for cache_item in $CACHEUPDATE_LIST; do
		echo "$cache_item" >> "$SCRATCH_FILE-$cache_def".cache_list
	done
	CACHEUPDATE_LIST=$(< "$SCRATCH_FILE-$cache_def.cache_list")
elif [ "$cache_update" = rebuild ]; then
	for cache_item in $CACHEUPDATE_LIST; do
		echo "$cache_item" >> "$SCRATCH_FILE-$cache_def".cache_list
		rm -f "$BLOG_DIR/$CACHE_DIR/$cache_item.$cache_def"
	done
	CACHEUPDATE_LIST=$(< "$SCRATCH_FILE-$cache_def.cache_list")
else
	[ ! -z "$cache_update" ] && query_db "$cache_update" "$db_catquery"
	for cache_item in $DB_RESULTS; do	
		rm -f "$BLOG_DIR/$CACHE_DIR/$cache_item.$cache_def"
	done
fi
CACHE_LIST=`echo "$CACHEUPDATE_LIST" |sort -u`
}

# generate the archives
build_archives(){
load_plugins archive
nb_msg "$buildarchives_action"
# build/update the category archives
build_catarchives
if [ "$USR_QUERY" = all ]; then
	# build the monthly archives
	query_db all
	loop_archive "$DB_RESULTS" months build_montharchive
	# build the entry archives
	[ "$ENTRY_ARCHIVES" = 1 ] &&
		build_entryarchives "$UPDATE_LIST" "$PERMALINKENTRY_TEMPLATE"
else
	# update relateive month archives
	MOD_MONTHS=`echo "$UPDATE_LIST" |sort $SORT_ARGS`
	loop_archive "$MOD_MONTHS" months build_montharchive
	# update relative entry archives
	[ "$ENTRY_ARCHIVES" = 1 ] &&
		build_entryarchives "$UPDATE_LIST" "$PERMALINKENTRY_TEMPLATE"
fi
}

# build the weblog
build_weblog(){
# update archives based on a query match
if [ -f "$BLOG_DIR/.nb_newblogdir" ]; then
	USR_QUERY=all
	rm -f "$BLOG_DIR/.nb_newblogdir"
fi
if [ "$USR_QUERY" = all ]; then
	nb_msg "$buildweblog_all"
	# remove all generated files for a clean build
	rm -fr "$BLOG_DIR"/{"$ARCHIVES_DIR","$CACHE_DIR","$PARTS_DIR"}/*
fi
if [ -z "$USR_QUERY" ]; then
	USR_QUERY="current"
else
	db_query="$USR_QUERY"; query_db "$db_query"
	UPDATE_LIST="$DB_RESULTS"
fi
# query database and check for categories
db_catquery=`cat_id`; check_catid
[ -z "$CAT_LIST" ] &&
	find_categories "$UPDATE_LIST"
update_cache all entry_metadata
load_plugins
# update previously cached entries
update_cache rebuild entry_metadata "$CACHE_LIST"
# build the archives
nb_msg "$buildweblog_files"
[ "$USR_QUERY" != main ] && build_archives
# build main index
update_cache "$QUERY_MODE" entry_metadata
nb_msg "$buildweblog_main"
paginate "$QUERY_MODE" nocat "$MAX_ENTRIES" "$MAIN_TEMPLATE" "$BLOG_DIR/" "$NB_INDEXFILE"
}

# edit draft file
nb_draft(){
EDITDRAFT_FILE="$1"
[ ! -z "$USR_DRAFTFILE" ] && EDITDRAFT_FILE="$USR_DRAFTFILE"
if [ ! -z "$EDITDRAFT_FILE" ] && [ ! -f "$EDITDRAFT_FILE" ]; then
	nb_msg "$draft_asknew [Y/n]"
	read -p "$NB_PROMPT" choice
	case $choice in
		[Yy]|"")
			# accept user metadata
			[ ! -z "$USR_AUTHOR" ] && NB_MetaAuthor="$USR_AUTHOR"
			[ ! -z "$USR_DESC" ] && NB_MetaDescription="$USR_DESC"
			[ ! -z "$USR_TITLE" ] && NB_MetaTitle="$USR_TITLE"
			[ ! -z "$USR_TEXT" ] && NB_MetaBody="$USR_TEXT"
			make_file "$EDITDRAFT_FILE";;
		[Nn])
		;;
	esac
fi
if [ -f "$EDITDRAFT_FILE" ]; then
	nb_edit "$EDITDRAFT_FILE"
fi
}

# add a new entry
add_entry(){
db_catquery=`cat_id`; check_catid
[ ! -z "$cat_num" ] && nb_msg "$addentry_catinfo $cat_num ..."
nb_msg "$addentry_action"
NB_EntryDate=`filter_dateformat "$DATE_FORMAT"`
NB_EntryTimeStamp=`nb_timestamp`
# fallback to printable timestamp
if [ -z "$NB_EntryDate" ]; then
	nb_msg "$filter_datefailed"
	NB_EntryDate=`filter_timestamp "$NB_EntryTimeStamp"`
fi
# load user specified timestamp
if [ -f "$NB_EditFile" ]; then
	read_metadata TIMESTAMP "$NB_EditFile"
	New_TimeStamp="$METADATA"
fi
[ "$USR_METATAG" = TIMESTAMP ] &&
	New_TimeStamp="$USR_TAGTEXT"
New_EntryFile="$NB_EntryTimeStamp.$NB_DATATYPE"
write_entry "$NB_DATA_DIR/$New_EntryFile"
chg_entrydate "$New_EntryFile" "$New_TimeStamp"
[ ! -z "$New_EntryDateFile" ] &&
	New_EntryFile="$New_EntryDateFile"
if [ ! -z "$cat_num" ]; then
	db_catquery=`cat_id`; check_catid
	for cat_db in $db_catquery ; do 
		echo "$New_EntryFile" >> "$NB_DATA_DIR/$cat_db"
	done
fi
UPDATE_LIST="$New_EntryFile"
build_weblog
}

# edit entry or category by id number
edit_weblog(){
if [ ! -z "$cat_num" ] && [ "$edit_num" = cat ]; then
	cat_var=`echo "$cat_num" |sed -e '/,/d'`
	[ -z "$cat_var" ] && die "$editweblog_onecat"
	db_catquery=`cat_id`; check_catid
	query_db "$db_query" "$db_catquery"
	if [ ! -z "$USR_TITLE" ]; then
		nb_msg "$editweblog_title"
		nb_msg "$header_Title - [$header_Category]" 
		nb_msg "$USR_TITLE - [$cat_num]"
		echo "$USR_TITLE" > "$NB_DATA_DIR/$db_catquery"
		[ ! -z "$DB_RESULTS" ] && echo "$DB_RESULTS" >> "$NB_DATA_DIR/$db_catquery"
		UPDATE_LIST="$DB_RESULTS"
		build_weblog; exit 0
	else
		die "$editweblog_nomod"
	fi
fi
NUMVAR=`echo "$edit_num" |grep '[0-9]' |sed -e '/[\,]/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "$novalid_entryid"
db_catquery=`cat_id`; check_catid
query_db "$db_query" "$db_catquery"; ENTRY_LIST="$DB_RESULTS"
for entry_id in $NUMVAR; do
	Edit_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	[ ! -f "$NB_DATA_DIR/$Edit_EntryFile" ] && die "$invalid_entryid $edit_num"
done
> "$SCRATCH_FILE"
for entry_id in $NUMVAR; do
	Edit_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	# write any user metadata
	write_tag "$USR_METATAG" "$USR_TAGTEXT" "$NB_DATA_DIR/$Edit_EntryFile"
	nb_edit "$NB_DATA_DIR/$Edit_EntryFile"
	# load user specified timestamp
	read_metadata TIMESTAMP "$NB_DATA_DIR/$Edit_EntryFile"
	New_TimeStamp="$METADATA"
	[ "$USR_METATAG" = TIMESTAMP ] &&
		New_TimeStamp="$USR_TAGTEXT"
	chg_entrydate "$Edit_EntryFile" "$New_TimeStamp"
	[ -f "$NB_DATA_DIR/$New_EntryDateFile" ] &&
		Edit_EntryFile="$New_EntryDateFile"
	[ -N "$NB_DATA_DIR/$Edit_EntryFile" ] &&
		echo "$Edit_EntryFile" >> "$SCRATCH_FILE"
done
UPDATE_LIST=$(< "$SCRATCH_FILE")
if [ ! -z "$UPDATE_LIST" ]; then
	nb_msg "$editweblog_action"
	build_weblog
else
	die "$editweblog_noaction"
fi
}

# delete entry or category by id number
delete_weblog(){
db_catquery=`cat_id`; check_catid
if [ ! -z "$cat_num" ]; then
	cat_list="$db_catquery"
fi
if [ ! -z "$cat_num" ] && [ "$delete_num" = cat ]; then
	nb_msg "$deleteweblog_delcat $cat_num ..."
	query_db "$db_query" "$cat_list"; UPDATE_LIST="$DB_RESULTS"
	for cat_db in $cat_list; do
		rm -f "$NB_DATA_DIR/$cat_db" "$BLOG_DIR/$ARCHIVES_DIR"/`chg_suffix "$cat_db"`
	done
	cat_num=; [ ! -z "$UPDATE_LIST" ] && build_weblog; exit 0
fi
NUMVAR=`echo "$delete_num" |grep '[0-9]' |sed -e '/[\,]/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "$novalid_entryid"
if [ ! -z "$cat_list" ]; then
	CATNUMVAR=`echo "$cat_num" |grep '[0-9]' |sed -e '/[\,]/ s// /g; /[A-Z,a-z\)\.\-]/d'`
	[ -z "$CATNUMVAR" ] &&
		die "$deleteweblog_onecat"
fi
query_db "$db_query" "$cat_list"; ENTRY_LIST="$DB_RESULTS"
for entry_id in $NUMVAR; do
	Delete_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	[ ! -f "$NB_DATA_DIR/$Delete_EntryFile" ] && die "$invalid_entryid $delete_num"
done
[ ! -z "$cat_num" ] && nb_msg "$deleteweblog_catinfo $cat_num"
nb_msg "$deleteweblog_delentry $delete_num ..."
UPDATE_LIST=`for entry_id in $NUMVAR; do echo "$DB_RESULTS" |sed -n "$entry_id"p; done`
find_categories "$UPDATE_LIST"
for entry_id in $NUMVAR; do
	Delete_EntryFile=`echo "$ENTRY_LIST" |sed -n "$entry_id"p`
	if [ -f "$NB_DATA_DIR/$Delete_EntryFile" ]; then
		if [ ! -z "$cat_list" ]; then
			for cat_db in $cat_list; do
				cat_mod=`grep "$Delete_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ ! -z "$cat_mod" ] && [ ! -z "$Delete_EntryFile" ]; then
					sed -e '/'$Delete_EntryFile'/d' "$NB_DATA_DIR/$cat_db" \
					> "$NB_DATA_DIR/$cat_db".tmp
					mv "$NB_DATA_DIR/$cat_db".tmp "$NB_DATA_DIR/$cat_db"
				fi
			done
		else
			for cat_db in $db_categories; do
				cat_mod=`grep "$Delete_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ ! -z "$cat_mod" ] && [ ! -z "$Delete_EntryFile" ]; then
					sed -e '/'$Delete_EntryFile'/d' "$NB_DATA_DIR/$cat_db" \
					> "$NB_DATA_DIR/$cat_db".tmp
					mv "$NB_DATA_DIR/$cat_db".tmp "$NB_DATA_DIR/$cat_db"
				fi
			done
			rm -f "$NB_DATA_DIR/$Delete_EntryFile"
			set_entrylink "$Delete_EntryFile"
			Delete_PermalinkFile="$BLOG_DIR/$ARCHIVES_DIR/$permalink_file"
			Delete_PermalinkDir="$BLOG_DIR/$ARCHIVES_DIR/$entry_dir"
			# delete permalink file
			[ -f "$Delete_PermalinkFile" ] && rm -fr "$Delete_PermalinkFile"
			# delete permalink directory
			[ ! -z "$entry_dir" ] && [ -d "$Delete_PermalinkDir" ] &&
				rm -fr "$Delete_PermalinkDir"
			# delete entry's cache file
			rm -f "$BLOG_DIR/$CACHE_DIR/$Delete_EntryFile".*
		fi
	fi
done
build_weblog
}

# list entries and categories
list_weblog(){
query_db; db_query="$USR_QUERY"
db_catquery=`cat_id`; check_catid
if [ "$db_query" = cat ]; then
	[ -z "$db_categories" ] && die "$listweblog_nocat"
	nb_msg "$header_ID, $header_Title"
	id=0
	cat_total=`echo "$db_categories" |grep -c "[\.]$NB_DBTYPE"`
	while [ "$id" != "$cat_total" ]; do
		id=`expr 1 + $id`
		if [ -f "$NB_DATA_DIR/cat_$id.$NB_DBTYPE" ]; then
			echo " $id, `sed 1q "$NB_DATA_DIR"/cat_$id.$NB_DBTYPE`"
		else
			cat_total=`expr 1 + $cat_total`
		fi
	done; exit 0
fi
# default to entries listed by limit
[ -z "$db_query" ] && db_query="$QUERY_MODE"
list_query="$db_query"
query_db "$db_query" "$db_catquery"
[ -z "$DB_RESULTS" ] && die "'$list_query' - $listweblog_nomatch"
nb_msg "$header_ID, $header_Title - [$header_Category] - $header_Date"
id=0
for entry in $DB_RESULTS; do
	for cat_db in $db_categories; do
		cat_var=`grep "$entry" "$NB_DATA_DIR/$cat_db"`
		if [ ! -z "$cat_var" ]; then
			cat_title=`sed 1q "$NB_DATA_DIR/$cat_db"`
			[ "$cat_title" != "$oldcat_title" ] && cat_title="$oldcat_title $cat_title"
			oldcat_title="$cat_title,"
		fi
	done
	cat_title=`echo $cat_title |sed -e '{$ s/\,[ ]$//g; }'`
	[ ! -z "$cat_title" ] && NB_Category="- [$cat_title] -" || NB_Category="-"
	read_metadata TITLE "$NB_DATA_DIR/$entry"; NB_EntryTitle="`echo "$METADATA" |cut -c1-32`..."
	read_metadata DATE "$NB_DATA_DIR/$entry"; NB_EntryDate="$METADATA"
	id=`expr 1 + $id`
	echo " $id, $NB_EntryTitle $NB_Category $NB_EntryDate"
	oldcat_title=; cat_title=; NB_Category=
done
}

# move entries into other categories
move_entry(){
NUMVAR=`echo "$move_num" |grep '[0-9]' |sed -e '/[\,]/ s// /g; /[A-Z,a-z\)\.\-]/d'`
[ -z "$NUMVAR" ] && die "$novalid_entryid"
query_db
for entry_id in $NUMVAR; do
	Move_EntryFile=`echo "$DB_RESULTS" |sed -n "$entry_id"p`
	[ ! -f "$NB_DATA_DIR/$Move_EntryFile" ] && die "$invalid_entryid $move_num"
done
db_catquery=`cat_id`; check_catid; [ -z "$cat_num" ] && die "$moveentry_catfirst"
nb_msg "$moveentry_catinfo $cat_num"
nb_msg "$moveentry_moventry $move_num ..."
UPDATE_LIST=`for entry_id in $NUMVAR; do echo "$DB_RESULTS" |sed -n "$entry_id"p; done`
query_db "$db_query" "$db_catquery"
for entry_id in $UPDATE_LIST; do
	Move_EntryFile="$entry_id"
	if [ -f "$NB_DATA_DIR/$Move_EntryFile" ]; then
		if [ ! -z "$db_catquery" ]; then
			for cat_db in $db_categories; do
				cat_mod=`grep "$Move_EntryFile" "$NB_DATA_DIR/$cat_db"`
				if [ -z "$cat_mod" ]; then
					echo "$Move_EntryFile" >> "$NB_DATA_DIR/$cat_db"
				fi
			done
		fi
	fi
done
find_categories "$UPDATE_LIST"
build_weblog
}

preview_weblog(){
[ -z "$BLOG_PREVIEW_CMD" ] && die "$preview_nocmd"
nb_msg "$preview_action"
$BLOG_PREVIEW_CMD
}

preview_ask(){
nb_msg "$preview_asknow [y/N]"
read -p "$NB_PROMPT" choice
case $choice in
	[Yy])
		preview_weblog;;
	[Nn]|"")
	;;
esac
}

publish_weblog(){
[ -z "$BLOG_PUBLISH_CMD" ] && die "$publish_nocmd"
nb_msg "$publish_action"
$BLOG_PUBLISH_CMD
}

publish_ask(){
nb_msg "$publish_asknow [y/N]"
read -p "$NB_PROMPT" choice
case $choice in
	[Yy])
		publish_weblog;;
	[Nn]|"")
		;;
esac
}

# create a new entry, category or weblog directory
add_weblog(){
load_config
[ -z "$BLOG_DIR" ] && die "$addweblog_noweblog"
# automatically create new weblog directory ...
if [ ! -d "$BLOG_DIR" ]; then
	nb_msg "$addweblog_newblog '$BLOG_DIR' ..."
	mkdir -p "$BLOG_DIR"
	[ ! -d "$BLOG_DIR" ] &&
		die "$addweblog_nocreate"
	> "$BLOG_DIR/.nb_newblogdir"
	nb_msg "$addweblog_copyaction"
	# copy default files and directories
	for weblog_dir in "$NB_BASE_DIR"/default/*; do
		cp -R "$weblog_dir" "$BLOG_DIR"
	done
	# create some critical empty directories
	for weblog_emptydir in "$ARCHIVES_DIR" "$CACHE_DIR" "$PARTS_DIR"; do
		[ ! -d "$BLOG_DIR/$weblog_emptydir" ] && mkdir "$BLOG_DIR/$weblog_emptydir"
	done
	# ... but prompt for configuration.
	nb_msg "$addweblog_askconf [Y/n]"
	read -p "$NB_PROMPT" choice
	case $choice in
	[Yy]|"")
		nb_msg "$addweblog_confaction"
		nb_edit "$BLOG_DIR"/blog.conf
		exit 0;;
	[Nn])
		die "$addweblog_noconf";;
	esac
fi
check_config
# create a new category 
if [ ! -z "$cat_num" ]; then
	if [ "$cat_num" = new ]; then
		query_db; id=0
		cat_total=`echo "$db_categories" |grep -c "[\.]$NB_DBTYPE"`
		while [ "$id" != "$cat_total" ] || [ "$cat_total" = "0" ]; do
			id=`expr 1 + $id`
			if [ ! -f "$NB_DATA_DIR/cat_$id.$NB_DBTYPE" ]; then
				nb_msg "$addweblog_newcat id: $id ..."
				if [ ! -z "$USR_TITLE" ]; then
					cat_title=$USR_TITLE; USR_TITLE=
				else
					echo "$addweblog_titlecat [Untitled]"
					read -p "$NB_PROMPT" cat_title
					[ -z "$cat_title" ] && cat_title=Untitled
				fi
				echo "$cat_title" > "$NB_DATA_DIR"/cat_$id.$NB_DBTYPE
				cat_num="$id"; db_catquery=`cat_id`; check_catid; cat_total="$id"
			else
				cat_total=`expr 1 + $cat_total`
			fi
		done
		nb_msg "$addweblog_madecat '$cat_title'."; exit 0
	else
		db_catquery=`cat_id`; check_catid
	fi
fi
# add new entry from metadata file
if [ ! -z "$USR_ADDFILE" ]; then
	if [ -f "$USR_ADDFILE" ]; then
		load_metadata ALL "$USR_ADDFILE"
	else
		nb_msg "'$USR_ADDFILE' $addweblog_nofile"
	fi
fi
# read user specified attributes for entry (interactively)
[ ! -z "$USR_TITLE" ] && NB_EntryTitle="$USR_TITLE"; USR_TITLE=
[ ! -z "$USR_AUTHOR" ] && NB_EntryAuthor="$USR_AUTHOR"
if [ -z "$NB_EntryAuthor" ] && [ "$BLOG_IPROMPT" = 1 ]; then
	nb_msg "$addweblog_author [$BLOG_AUTHOR]"
	read -p "$NB_PROMPT" NB_EntryAuthor
fi
[ -z "$NB_EntryAuthor" ] && NB_EntryAuthor="$BLOG_AUTHOR"
if [ -z "$NB_EntryTitle" ] && [ "$BLOG_IPROMPT" = 1 ]; then
	nb_msg "$addweblog_title"
	read -p "$NB_PROMPT" NB_EntryTitle
fi
[ ! -z "$USR_TEXT" ] && NB_EntryBody="$USR_TEXT"; USR_TEXT=
if [ -z "$NB_EntryBody" ]; then
	nb_msg "$addweblog_editnew"
	# new entry temp file for editing
	NB_EditFile="$BLOG_DIR/nb_edit-newentry-`nb_timestamp`.$NB_DATATYPE"
	# write any user metadata
	write_tag "$USR_METATAG" "$USR_TAGTEXT" "$NB_EditFile"
	# write current metadata to temp file and edit
	write_entry "$NB_EditFile"; nb_edit "$NB_EditFile"
	# load all new entry metadata from temp file
	if [ -f "$NB_EditFile" ]; then
		load_metadata ALL "$NB_EditFile"
	fi
fi
[ ! -z "$USR_DESC" ] && NB_EntryDescription="$USR_DESC"
# prompt for description
if [ -z "$NB_EntryDescription" ] && [ "$DESC_PROMPT" != 1 ] &&
	[ "$BLOG_IPROMPT" = 1 ]; then
		nb_msg "$addweblog_desc"
		read -p "$NB_PROMPT" NB_EntryDescription
fi
# set a default entry format
[ -z "$NB_EntryFormat" ] && NB_EntryFormat="$ENTRY_FORMAT"
# generate date format for entry's content
NB_EntryDate=$(filter_dateformat "$DATE_FORMAT")
# reload configuration
check_config
add_entry
# remove editing session file upon success
[ -f "$NB_EditFile" ] && trap "rm -fr $NB_EditFile" 0
#rm -f "$NB_EditFile"
[ ! -z "$BLOG_PREVIEW_CMD" ] && preview_ask
[ ! -z "$BLOG_PUBLISH_CMD" ] && publish_ask
}

show_help(){
NB_ShowHelp=$(< "${NB_LANG_DIR}/$NB_LANG"/help.lang)
BASENAME=`basename $0`
sed -e '/[\$]VERSION/ s//'$VERSION'/g; /[\$]BASENAME/ s//'$BASENAME'/g' <<-EOF
	$NB_ShowHelp
EOF
}

# load global config
load_globals
# load language definitions
. ${NB_LANG_DIR}/$NB_LANG/messages.lang
. ${NB_LANG_DIR}/$NB_LANG/plugins.lang

argument=$@
[ $# -lt 1 ] && show_help
check_arg(){
if [ -z "$argument" ]; then
	echo "$bad_argument $checkarg_badarg"
	echo "$checkarg_help"
	exit 1
fi
}
sanity_check(){
invalid_opt=`echo "$argument" |grep '^[--]$*'`
[ ! -z "$invalid_opt" ] && argument=
}
while [ $# -gt 0 ]; do
	[ $# -gt 1 ] && argument=$2
	bad_argument=$1
	case "$1" in
		-a|--add)		add_weblog;;
		-b|--blogdir)		check_arg; USR_BLOGDIR="$2"; shift;;
		# -B, --body options deprecated
		-B|--body)		check_arg; USR_TEXT="$2"; shift;;
		-c|--category)		check_arg; cat_num="$2"; shift;;
		--configure)		check_config; config_weblog;;
		--datadir)		check_arg; USR_DATADIR="$2"; shift;;
		-d|--delete)		check_arg; delete_num="$2"; shift
					check_config; delete_weblog;;
		-D|--desc)		DESC_PROMPT=1; USR_DESC="$2"; shift;;
		-e|--edit)		check_arg; edit_num="$2"; shift
					check_config; edit_weblog;;
		-E|--draft) 		check_arg; USR_DRAFTFILE="$2"; shift
					check_config; nb_draft;;
		-f|--blogconf)		USR_BLOGCONF="$2"; shift;;
		-F|--file) 		check_arg; USR_ADDFILE="$2"; shift;;
		-h|--help)		show_help; exit 0;;
		-i|--interact) 		BLOG_IPROMPT=1;;
		-l|--list)		USR_QUERY="$2"; shift
					check_config; list_weblog;;
		-n|--author)		check_arg; USR_AUTHOR="$2"; shift;;
		--manual)		check_config; $BROWSER "$NB_BASE_DIR/docs/nanoblogger.html";;
		-m|--move)		check_arg; move_num="$2"; shift
					check_config; move_entry;;
		-M|--makepage)		check_arg; USR_SRCFILE="$2"; USR_OUTFILE="$3"; shift 2
					check_config; weblog_page;;
		-p|--preview)		check_config; preview_weblog;;
		-P|--publish)		check_config; publish_weblog;;
		--template)		check_arg; USR_TEMPLATE="$2"; shift;;
		--template-dir)		check_arg; USR_TEMPLATE_DIR="$2"; shift;;
		-t|--title)		check_arg; USR_TITLE="$2"; shift;;
		--tag) 			check_arg; USR_METATAG="$2"; shift;;
		--tag-text) 		check_arg; USR_TAGTEXT="$2"; shift;;
		-T|--text) 		check_arg; USR_TEXT="$2"; shift;;
		-u|--update)		USR_QUERY="$2"; shift
					check_config; build_weblog;;
		-v|--verbose)		check_arg; VERBOSE="$2"; shift;;
		-V|--version)		echo "NanoBlogger $VERSION"; exit 0;;
		--)			shift; break;;
		*)
					sanity_check
					echo "$main_badopts $@"
					echo "$main_panic"
					exit 1
					;;
	esac
	shift
done

exit 0

#
# End of script
#

